---
title : '[Effective Java] 아이템42 익명 클래스보다는 람다를 사용하라'
date : 2021-05-22 14:22:12
category : 'Effective Java'
draft : false
description : "아이템42 익명 클래스보다는 람다를 사용하라"
tags : ['Java']
---


<br/>

#### 람다식과 익명 클래스

이전에는 함수 객체를 만들 때 익명 클래스를 주로 사용하였습니다.

하지만 익명 클래스 방식은 코드가 길어서 JDK 1.8버전 부터는 **추상 메서드 하나짜리의 인터페이스의 인스턴스**를 의미하는 `람다식`이라는 것을 사용할 수 있게 됐습니다.

```java

Collections.sort(words, new Comparator<String>() {
            public int compare(String s1, String s2) {
                return Integer.compare(s1.length(),
s2.length());
            }
});

```


위의 익명 클래스로 되어있는 Sorting을 밑의 람다식으로 변환할 수 있습니다.

<br/>


```java

Collections.sort(words,
                (s1, s2) -> Integer.compare(s1.length(), s2.length()));

```

위의 코드는 아래와 같이 좀 더 간략하게 표현할 수 있습니다.

<br/>

```java
Collections.sort(words,
Comparator.comparingInt(String::length));

```

위의 람다식 표현들을 보면 **타입에 대한 언급이 없습니다**

**컴파일러가 타입 추론을 대신해주기 때문에 타입에 대한 언급이 필요가 없습니다.**

<br/>

#### 람다를 사용하지 말아야 할 때

람다를 사용하기에 적절하지 못한 경우도 있습니다.

이름도 없고 메서드나 클래스와 다르게 문서화를 할 수 없기 때문에

**코드 자체로 동작이 명확하게 설명되지 않으면 사용하는것을 고려**해야 합니다.

<br/>

#### 람다의 단점

1. **추상클래스의 인스턴스를 만들 때 람다사용이 불가능하기 때문에 익명클래스를 사용하여야** 합니다.

2. **추상메서드가 두개 이상이면 람다사용이 불가능합니다**

3. `this`는 자기 참조를 하는 것이 아니라 **바깥의 인스턴스를 가리킵니다**.

그렇기 때문에 함수 객체가 자기자신을 참조해야하는 상황이 와야 한다면, **익명 클래스를 사용해서 표현**을 해야 합니다.

<br/>

#### 직렬화

가상머신마다 직렬화의 형태가 다르기 때문입니다.

직렬화가 필요한 경우에는 람다와 익명클래스를 사용하지 않는 것이 좋습니다.




