---
title : '[Basics] 컴퓨터망 3장'
date : 2021-05-02 19:22:12
category : 'Basics'
draft : false
description : "컴퓨터망 3장"
tags : ['OS']
---

# 컴퓨터망 3장 - Transport Layer
#컴퓨터망

Transport Layer는 이렇게 정의 내릴 수 있다.

네트워크 계층에서 제공하는 서비스를 애플리케이션 계층에서 요구하는 서비스에 맞게 변환해주는 계층

Internet은 best-effort이다. 데이터의 순서 보장도 하지않고 packet loss도 신경쓰지않는다.

Transport layer는 application에서 요청한 데이터를 segment 단위로 잘라서 전송을 해준다. 패킷순서와 같은 정보를 헤더에 담아서 전송한다.

TCP , UDP layer로 분류 할 수 있다.

TCP라도 암호화가 제공되지 않아서 보안성을 보장하지는 않는다.
Bandwith, 암호화,minimum bandwidth 같은 것을 보장하지 않는다. 

Transport -> application demultiplexing

transport는 데이터를 application 계층에게 전송을 하기 위해서는 portnum으로 프로세스를 구별해서 이에 맞는 application에게 전송해줄수있다.

호스트는 IP로 구별을 하고 프로세스는 portNum으로 구별을 하고있다.
- - - -
Connection - oriented -> TCP UDP는 연결을 보장하고 전송을 하는 것이 아니다..
socket의 구성을 ip,port 이렇게 두개로 나누어서 수신자와 송신자를 식별한다.

![img](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.02.36.png)

TCP는 연결보장, UDP는 송신자와 수신자사이에 연결을 할 필요가 없다.

TCP는 패킷의 순서보장, packet loss에 대한 대비를 한다. 이말은 네트워크의 congestion control, flow control 도 할 수 있다는 말이다..

UDP는 송수신자사이에 연결을 하지않고 데이털르 전송하기 떄문에 패킷로스, 데이터의 순서보장을 하지 않는다. 물론 congestion control, flow control 또한 보장하지않는다.

=> Smll header size, no congestion control이기 떄문에 전송속도가 TCP에 비해 빠르다.

UDP가 사용되는 곳 ? => DNS, **SNMP**(네트워크 상태를 묻는), HTTP/3( udp위에 quic 프로토콜을 올림으로서 HTTP/3를 구현한다.
![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.09.42.png)

DL은 데이터에 이상이 있는지 check를 해주는 것이지,,, TransPort layer에서는 데이터 순서가 맞는지 아닌지를 검사해준다.

주의해라!!!!! `UDP에도 checkSum 은 존재한다`

udp는 패킷로스, 순서를 보장하지 않는것이지 에러체크는 한다.

체크섬은 **전송된 데이터가 변형이 되지 않았는지 확인하는 값**이다. 
전송하려는 세그먼트의 값들을 이용해 **체크섬을 만들어서 세그먼트에 담아 전송**한다. 
전송하려는 세그먼트의 값을 16bit형태로 주욱 나열한다. 
그리고 1의 보수들을 전부더한다.
세그먼트를 받은 상대는 **세그먼트의 값들을 이용해 다시 체크섬을 계산하고 세그먼트에 저장된 체크섬 값과 비교**한다. 
세그먼트의 값들 중 하나라도 변경되면 체크섬 값이 바뀌기 때문에 이 **두 값이 다르다면 전송 중 세그먼트의 내용이 변형되었음을 의미**한다.

UDP는 TCP와 다르게 연결보장을 할필요가 없기때문에, setup과정에서 RTT시간만큼 들지 않는다.

- - - -
TCP에서 신뢰적인 데이터를 전송할때 애플리케이션은 신뢰성 채널을 통해 데이터를 전송하는 것으로 알고있지만, 실제로는 Unrealiable channel을 통해서 데이터를 전송하고, 신뢰적으로 데이터를 전송하게 보장하는것은 transport layer를 통해 이루어지고있다.

- - - -
1. **rdt1.0 => 데이터를 전송할때 bit error도 없고 loss packet일때**
![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.20.14.png)

무조건 전송하면 성공하기 때문에 state가 1개만 있으면 된다.

2. rdt2.0 => 데이터를 전송할떄 bit error와 packet loss가 있을 때
NAK, ACK을 사용하여 데이터가 정상적으로 송신되었는지 아닌지 송신자는 확인할 수 있다.
=> `checksum`을 데이터 전송에 포함시킨다. **에러 측정을 위해서**!!!

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.22.13.png)

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.23.38.png)

수신자입장에서는 아까와 다르게 corrupt를 통해서 데이터에 오류가있는지 확인하고 ACK,NAK을 보내게 된다.

3. **rdt2.1 => ACK / NAK 자체에 오류가 있을 때???**

송신자입장에서 ACK이 파괴되어왔을 때, 수신자는 정상적으로 데이터를 받았음에도 불구하고 송신자는 데이터가 잘못전송되었다고 판단하여 중복된 데이터를 보낼 수 있다.

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.33.14.png)

ACK,NAK에도 오류가 생길수 있기때문에 조건에 corrupt(rcvpkt) 라는 조건이 추가되었다.

rdt_rc(rccpkt) && isNAK(rcvPacket) => rdt_rc(rcpakt && (**corrupt(rcPacket) || isNAK(rcvPacket)**) 이렇게 추가됨.

rdt_rc(rcvpkt( && isACK =>  rdt_rc(rcvpkt( && isACK && notcorrupt )

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.37.21.png)

수신자입장에서는 데이터가 1인지 0인지 판단을 해야하는 조건이 추가되어야한다.


4. rdt2.2 => 꼭 NAK를 써야하나 그냥 ACK를 쓰면안되나?

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.40.48.png)
ACK 뒤에 번호를 붙여서 받는다.
0을 기다리고있는데 1이라는 ACK이 오면 이는 정상적으로 데이터가 전송된것이 아니기때문에 이전 데이터 0을 받지못했다는 뜻이기 때문에 다시 데이터를 전송한다.

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.40.58.png)

5. rdt3.0 => ACK, sequnceq번호,checksum말고 timeout으로 판단을 해보자.

송신자입장에서는 ack을 기다리는 시간을 적당한 시간을 기다려야한다.
너무 오래 기다리면 다음 패킷전송이 느려지게 되고, 너무 짧게 기다리면 ACk이 오는 중일 수도 있는데 고려하지못하고 재전송을 하게 될 수 도 있다.

**RTT 시간** 만큼 기다려야한다 !! Sender <->receiver 사이 왔다갔다하는데 걸리는 왕복시간
![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.56.22.png)

**저기서 1을 받고도 무시하는 이유는?** 

송신자는 ACK0을 기다리고 있는데, ACK1을 무시하고 아무처리를 하지않는다. 그저 타임아웃에 의해서 재전송을 하도록 설정했기 떄문이다.

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.56.57.png)

1이라는 신호 요청을 기다리고 있는데 이전 데이터에 대한 ACK이 오면 그냥 무시하라는 의미이다. **ACK 전송이 timeout 이후에 와서 생기는 현상을 방지하기 위해서 넣은 것**


Tx=> 데이터를 내보는데 걸리는 시간은 L/R
Tp => D/속력 
데이터를 한번 보내는데 걸리는시간 => **Tx(실질적으로 데이터를 보내는데 걸리는시간)/2*Tp+Tx**
![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.01.27.png)

- - - -

오류 제어방법들

Cumulative ACK
Go-back N 
Selective N : 얘는 패킷로스된것만 다시 재전송해서 받기때문에 packet loss된 패킷이후의 패킷은 버퍼에다가 다 저장을 하고있어야한다.

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.28.40.png)

Selective N의 딜레마… 

세개다 받지못했을때 이때의 0은 재전송 데이터 0을 의미한다. 이것을 보내게되면 수신측 입장에서는 이 0은 새로운 데이터라고 생각하고 수신을 받을 것이다. 문제가 생기게됨

가 되어야한다. 이때의 k는 데이터종류의 비트 수 ( 만약 0,1,2,3 까지있으면 이는 k는 2로 표현할 수 있다. )

`NAK을 보내는 대신 이전에 보냈던것과 중복된 ACK을 보내면 송신측에서는 이를 무시하고 timeout됐을때 이전에 받지못한 ACK에 대한 데이터를 보내게 될 것이다.`


- - - -

<TCP 특징들 > - 중요

1) point-to-point 통신이다. 1대1 통신을 진행한다
2) reliable하게 전송한다 
3) byte 단위로 전송을 한다
4) packet의 순서 및 전송보장을 한다.
5) 송신자와 수신자간의 논리적인 연결이 이루어져야한다.
6) pipelining 전송 보장, cumulatvie ack을 사용할 수 있다.
7) flow control, congestion control 보장
8) bi-dircetional data flow를 보장한다


Sequence number는 실제로 0,1,2,3 이 아니라 1023,2046과 같이 bit 단위로 설정한다.

Piggy backing용 공간이 -> acknowledgment number이다
Receive Window는 flow control 용으로 쓰기 위해서 만들어놓았다.
송신자에게 수신측 버퍼상황을 알려주는 것
R, S , F= > RST(Reset connection) , SYN(Tcp connection을 하자고 알리는 것) , FIN(TCP 연결 disconnect)

Pbit => 버퍼에 데이터가 원래 어느정도차야지만 application layer에게 데이터를 up해주는데 이를 기다리지 않고 데이터를 받으면 곧바로 application 계층으로 올리게끔 하는 옵션을 설정하는 bit

Ubit => urgent bit를 의미한다. urgent한 데이터가 어딨는지 알려주는 것이다.

데이터를 송신자 입장에서 잘못보낸 상황에서 송신자는 수신자에게 데이터를 취소해야한다고 긴급하게 알려야한다. 하지만 **TCP 특성상 데이터를 순서대로 보내고 전송되기 때문에 취소메세지가 언제 수신되는지 알 수 없다**. 따라서 우선적으로 데이터를 읽을 수 있게 긴급한 정보가 있다고 표시를해서 전송하는 기능이 필요하다.

Options : 가변적으로 더 추가하고 싶은 정보를 추가하는 공간을 의미한다.

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.53.31.png)
![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.53.40.png)

- - - -
## fast retransmission

timeout이 발생하기 전에 duplicate Ack을 3개 보내서 fast retransmit을 통해 누락된 데이터를 재전송하는 방식

즉 타임아웃을 기다리지 않고 duplicate Ack을 3개보내서 재전송을 빨리 요청하는 방식이다. 제일 처음 보낸 ACK을 제외하고 중복된 ACK을 3개보냈을때 fast retransmit이 일어난다.

- - - -
Send와 receiver는 재전송상황에 대비해서 데이터를 buffering하고 있어야한다.
Send buffer , receiver buffer 이렇게 각자 두개의 buffer를 가지고 있어야한다.

Flow control은 송신측에서 수신측의 receiver buffer의 상황을 확인하면서 데이터를 전송하는 속도를 조절하는 방식이다.

수신자는 송신자에게 자신의 버퍼양이 어느정도있는지 tcp header의 **Rwnd필드**에 넣어서 알려준다.

송신자는 unAcked받지않은 상태에서 연속으로 보낼수있는 데이터양을 rwnd에 맞춘다.

- - - -
### tcp는 연결을 setup하는데 3-way handshake가 되어야하고 연결을 끊어버리는데는 4-way handshake가 되어야한다.

조심해라 4-way handshaking이 아니다… 3-way handshaking을 한다. 왜?? Piggy backing이 가능하기 떄문!!!

Synbit를 1로설정하고 상대방에게 패킷을 보내면, 상대방또한 synbit를 1로 보내면서 연결을 했다고 말해준다. 그리고 제일처음 ackbit를 1로 설정해주면서 같이 보내게 되는데 이때의 과정을 seq num을 알려주는 처음 과정이 된다.


![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.15.13.png)

### 연결을 끊어버리는데?
4 way hand shaking이 일어나야한다.

1. 왜?? 그냥 끊어버린다고하면안되는가?

A측에서 데이터를 보낼것이 없다고 그냥 닫아버리면 상대방은 아직 전송을 해야할 데이터가 있을 수 도 있기 때문에 상대방도 연결을 끊겠다는 FIN BIT를 받아야만한다.

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.21.04.png)

2. 마지막 ACK을 보내고 나서 왜 또 기다려야하는가 ?
=> 상대방의 FIN BIT 메세지에 대한 응답이 제대로 전송이 되지 않는 경우가 생길 수도 있는데, 만약에 ACK 메세지가 제대로 전송이 되지않고 나의 연결을 끊어버리면 상대방은 연결을 종료하지못하고 계속 기다리는 현상이 발생할 수 있다.

- - - -

### congestion한 상황을 판단하는 방법?

송신자가 데이터를 보내면 보내는 양만큼 비슷하게 데이터를 받아와야하는데 어느 순간 부터 보내는 양보다 받는 양이 적어진다면 이는 네트워크상황이 좋지 않다고 판단할 수 있다.

**Congestion control에 접근하는 방법**

**1) End-End congestion control**
중간에 있는 라우터들이 도와주지않고 host와 host간에 통신을 통해서 congestion을 확인하는 방법이다.

데이터를 보냈는데 ACK이 오지않는다거나, 데이터를 보내면 보낼수록 ACK 이 점점 늦게 도착할 때, 네트워크 상황이 좋지않다는 것을 판단할 수 있다.

**2) Network-assisted congestion control**
중간에 있는 라우터들이 congestion이 생기는 것을 알려주는 방식이다.

- - - -
### TCP congestion control - > AIMD 방식

AI : Additive Increase ( 데이터를 보내는 양을 1MSS만큼 점점 늘린다 )
MD : Multiplicative Decrease  ( congestion(event)가 생겨버리면 데이터의 전송양을 반으로 줄여버린다 ) -> `cwnd의 양을 줄인다!!! rwnd!=cwnd`
=> 보낸 데이터에 대한 ACK을 정상적으로 수신받지 못한다면 congestion이 생겼다고 판단하고 데이터 전송량을 줄여버린다.
 => fairness가 보장되어야한다.
이렇게 데이터전송양을 늘려도 내가 보낸 데이터의 양과 다른호스트가 보낸 데이터의 양이 공평해야한다.
cwnd와 rwnd는 다른것이다 !! cwnd는 전송양을 의미한다.


Tcp reno는 sending rate를 duplicate ACK가 3개올때 반으로 줄여버린다.
TCP Tahoe는 sending rate를 1MSS 만큼 줄이는 것이다.

- - - -

### TCP slow start => 여기 진짜 중요하다.

연속으로 보낼 수 있는 양 cwnd 라고 한다.
Congestion window size 

처음에는 cwnd는 1이고, 이게 증가하는 cwnd가 증가하는 단위는 **RTT**마다 증가하게 되는데 증가하는양은 1MSS 씩 증가시킨다.

여기서 1씩 증가하는 구간을 **congestion avoidance phase**라 한다


이렇게. Slow start를 거치다가. 임계값을 넘어서면 cwnd의 값을 linear하게 증가시킨다.

Congestion 감지는 send가 스스로 판단을한다. 
![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.34.47.png)

1. Time out
**이렇게 congestion이 발생하게 되면 cwnd를 무조건 1MSS로 줄이고 slow start의 한계치를 cwnd의 반으로 줄인후에 slow start를 다시 시작한다.**
**그 slow start 한계선을 지나면, 다시 linear 하게 증가시킨다.**
=> 이는 `TCP tahoe` 라고 한다.
tahoe같은경우는 duplicated ack이 와도 1MSS로 떨어드린다.

3. Triple duplicated ACk으로 확인할 수 있다.
=> duplicated ACK이 온다면 cwnd를 1로 초기화하는 것이 아니라 현재 cwnd를 반으로 줄여버리고 다시 linear하게 증가시키게 처리한다.
이를 `fast recovery`라고 하며 이는 `TCP Reno` 타입이라고도 한다.


4. `TCP Vegas `=> 미리 데이터를 보낼때마다 RTT를 측정하여, RTT가 늘어나면 전송데이터양을 감소시키는 TCP  프로토콜

5. `TCP Cubic` => congestion이 걸리고 나서 cwnd를 반으로 줄이고나서, linear하게 증가시키는 것이아니고 curve하게 증가하는 프로토콜을 의미함

![](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A1%E1%86%BC%203%E1%84%8C%E1%85%A1%E1%86%BC%20-%20Transport%20Layer1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.53.30.png)

- - - -
ECN 방법 => 네트워크 라우터들이 버퍼의 상황같은것을 알게되면 송신자에게 이러한 상황을 알려주는 방법

UDP는 congetsion control을 하지 않고 TCP는 congestion control을 하는데 이는 TCP는 unfair하는거 아닐까?

TCP와 UDP의 BUffer를 따로두어서 fairness를 지킬 수 있다.

- - - -
무선이나 통신망 때문에 데이터가 안보내질 수 있는데,  TCP는 이것을 네트워크 혼잡(congestion)이라고 한다.

QUIC 프로토콜은 TCP 프로토콜에 비해 연결 셋업 과정이 적다. TLS handshaking이 필요없다 !! => 1 handshake


HTTP1.1은 HOL이 생겨버린다. 
=> HTTP2가 pipeline 전송방식이 생기면서 HOL 현상이 해결되었다.
=> 하지만 setup 과정이 오래걸리고 TLS 연결을 별도로 진행해주어야한다 (HTTP2)
하지만 quic 프로토콜 (HTTP3)은 HOL blocking 현상이 일어나지 않는다.
1hand shake로 해결이 가능하다.

결국 보내는것과 받는 데이터가 같아야하기때문에 quic 프로토콜이 이러한 기능들이 다 구현이 되어있다.


