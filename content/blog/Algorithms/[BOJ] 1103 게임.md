---
title : '[BOJ] 1103 게임'
date : 2021-01-24 13:22:12
category : 'Algorithms'
draft : false
description : "1103 게임 문제풀이"
tags : ['DFS','DP']
---

* DFS
* DP


<br/>

![문제사진]()

![문제사진2]()


<br/>

[요구사항]

N개의 수가 주어지고, 그 중 a와 b번째 수 사이의 범위에서 최솟값과 최댓값을 찾을 수 있는지 요구하는 문제입니다.


<br/>







<br/> <br/>

```java

import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {


    static int N, M;
    static char[][] map;
    static int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    static int[][] dp;
    static boolean[][] visit;

    static final int INF = 1000000;

    public static void main(String[] argv) throws IOException {

        init();
        visit[0][0]=true;
        int answer=calc(0,0);


        if(answer==INF)
            System.out.println(-1);
        else
            System.out.println(answer);
    }

    public static void init() throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        map=new char[N][M];
        dp=new int[N][M];

        for(int i=0;i<N;i++){
            Arrays.fill(dp[i],-1);
            String cur = br.readLine();
            for(int j=0;j<M;j++){
                map[i][j]=cur.charAt(j);
            }
        }

        visit= new boolean[N][M];
    }

    public static int calc(int x,int y){

        if(dp[x][y]!=-1) return dp[x][y];

        dp[x][y]=0;
        int tmp=0;
        for(int i=0;i<4;i++){
            int nx=x+dir[i][0]*(map[x][y]-'0');
            int ny=y+dir[i][1]*(map[x][y]-'0');

            if(nx<0 || nx>=N || ny<0 || ny>=M || map[nx][ny]=='H'){
                tmp=Math.max(tmp,1);
                continue;
            }

            if(visit[nx][ny]){
                return INF;
            }
            else{
                visit[nx][ny]=true;
                int answer=calc(nx,ny);
                if(answer==INF)
                    return dp[x][y]=INF;
                else
                    tmp=Math.max(tmp,answer+1);
                visit[nx][ny]=false;
            }
        }

        dp[x][y]=tmp;

        return dp[x][y];
    }




}


```